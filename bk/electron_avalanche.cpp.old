#include "electron_avalanche.hpp"

using namespace std;

typedef unsigned int uint;

extern double d;
extern int Nstep;
extern double Dx;
extern double alpha;
extern double eta;
extern double k;
extern double spaceChargeLimit;
extern double dl;
//double l = 0.1;
double thrCLT = 1e5;

TRandom3 r(0);
TRandom3 rCLT(456);
TRandom3 rLongiDiff(758);

double n_moy(double const& x){
	return exp((alpha-eta)*x);
}

int electron_multiplication2(double const& x, double const& s){
	//double s = r.Rndm();
	double nm = n_moy(x);
	double thr = k * (nm-1)/(nm-k);
	
	if (s<=thr)
		return 0;
	else
	{
		if (nm > 1.e5)
		{
			int val = 1 + int( log((nm-k)*(1-s)  / (nm * (1-k))) / (-( (1-k)/(nm-k) + 0.5*pow((1-k)/(nm-k),2) + 0.5*pow((1-k)/(nm-k),3)) ) );
			return val;
		}
		else
		{
			int val = 1 + int(log( (nm-k)*(1-s)  / (nm * (1-k)) ) / log( 1 - (1-k)/(nm-k) ));
			if(val<0)
			{
				cout << "s: " << s << endl;
				cin.ignore();
			}
			return val;
		}
	}
}

int multiplication(){
	//TRandom3 r(0);
	double s = r.Rndm();
	if (s==1)	s = r.Rndm();
	int nProduced = electron_multiplication2(Dx,s);
	return nProduced;
}

double multiplication(double n){
	double nProduced = 0;
	if(n > thrCLT){
		double c = CLT(Dx, n);
		if(c < 0){
			cout << c << " " << n << endl;
			cin.ignore();
		}
		return c;
	}
	for(int i=0; i<n; i++){
		double s = r.Rndm();
		if (s==1)	s = r.Rndm();
		nProduced += electron_multiplication2(Dx,s);
	}
	return nProduced;
}

int avalanche2(double const& x0, const int& n0, string filename, bool OMP){
	vector<double> x(1,x0);
	vector<int> n(1,n0);
	vector<int> nCLT(1,n0);
	int i=0;
	//TRandom3 r(0);
	//TRandom3 rCLT(456);
	ofstream data(filename.c_str(), ios::out | ios::trunc);
	
	while (x[i] < d){
		if(n[i] == 0){
			data.close();
			return 0;
		}
		else if (n[i] >= spaceChargeLimit)	break;
		x.push_back(x[i]+Dx);
		int nProduced = 0;
		int nProducedCLT = 0;
		
		if(i%100==0)
			cout << x[i] << "\t" << n[i] << "\t" << "\t" << log10(n[i]) << endl;
		data << x[i] << "\t" << n[i] << "\t" << nCLT[i] << endl;
		
		nProducedCLT = CLT(Dx, n[i]);
		
		for(int j=0; j<n[i]; j++){
			double s = r.Rndm();
			if (s==1)	s = r.Rndm();
			nProduced += electron_multiplication2(Dx,s);
		}
		n.push_back(nProduced);
		nCLT.push_back(nProducedCLT);
		i++;
	}
	data.close();
	return n[n.size()-1];
}

double CLT(double const& x, double const& n){
	//TRandom3 r(456);
	double nm = n_moy(x);
	double m = n*nm;
	double sigma = sqrt(n) * sqrt( ((1+k)/(1-k)) * nm * (nm-1) );
	double c = rCLT.Gaus(m,sigma);
	if(trunc(c)<0){
		cout << "CLT:" << endl;
		cout << "\tnm " << nm << endl;
		cout << "\tm " << m << endl;
		cout << "\tsigma " << sigma << endl;
		cout << "\ttest " << rCLT.Gaus(2.21e9,sigma) << endl;
		cout << "\ttest2 " << c << " " << int(trunc(c)) << " " << long(c) << endl;
	}
	return trunc(c);
}

void propagateToAnode(vector<double> &NElectrons, double* detectorGrid, int t){
	
	int timeStep = t;
	while(true){
		double copy[Nstep];
		memcpy(copy, detectorGrid, sizeof detectorGrid);
		for(int i=0; i<Nstep-1; i++){
			detectorGrid[i+1] = copy[i];
			detectorGrid[i] = 0;
			NElectrons[timeStep] += copy[i];
		}
		detectorGrid[Nstep] = 0; //electrons in the last detector step will leave the gas gap
		timeStep++;
		if(timeStep >= Nstep)	break;
	}
}

void computeLongitudinalDiffusion(double detectorGrid[]){
	double sigma = dl*sqrt(Dx);
	double newDetectorGrid[Nstep];
	for(int i=0; i<Nstep; i++)	newDetectorGrid[i] = 0;
	
	for(int iStep=0; iStep<Nstep; iStep++){
		for(int i=0; i<detectorGrid[iStep]; i++){
			double pos = (iStep+1)*Dx - 0.5*Dx;
			double newPos = rLongiDiff.Gaus(pos,sigma);
			if(newPos<=d or newPos>=0)	newDetectorGrid[int(trunc(newPos/Dx))] += 1;
		}
	}
	
	detectorGrid = newDetectorGrid;
}

bool avalanche(vector<double>& NElectrons, double detectorGrid[]){
	bool bSpaceChargeLimit = false;
	int timeStep = 1;
	while(true){
		if(NElectrons[timeStep-1] > spaceChargeLimit and !bSpaceChargeLimit)	bSpaceChargeLimit = true;
		double copy[Nstep];
		memcpy(copy, detectorGrid, sizeof(double)*Nstep);
		for(int i=0; i<Nstep-1; i++){
			double n = copy[i];
			double nProduced;
			if(bSpaceChargeLimit)	{
				nProduced = n;
				//detectorGrid[i] = 0;
			}
			else	nProduced = multiplication(n);
			detectorGrid[i+1] = nProduced;
			NElectrons[timeStep] += nProduced;
		}
		//computeLongitudinalDiffusion(detectorGrid);
		detectorGrid[Nstep] = 0; //electrons in the last detector step will leave the gas gap
		timeStep++;
		if(timeStep >= Nstep)	break;
	}
	return true;
}
//===============================================================================================================================================================

double F1(int const& n, double const& x){
	double a = n_moy(x) * pow( (1.-k) / (n_moy(x)-k) , 2);
	double b = ( (n_moy(x)-1.) / (n_moy(x)-k) );
	return (a / log(b)) * ( pow(b,n-1) - 1 );
}

double P(int const& n, double const& x){
	double n_m = n_moy(x);
	if (n==0)
		return k * ( (n_m-1.) / (n_m-k) );

	else 
	{
		double a = n_m * pow( (1.-k) / (n_m-k) , 2 );
		double b = ( (n_m-1.) / (n_m-k) );
		return a * pow(b,(n-1));
	}
}

//double cluster_dist(double const& s){
//	return -l * log(1+s);
//}

vector<double> make_cumulative_tabulation(double const& x){
	double nm = n_moy(x);
	vector<double> cumulative_tab(1,P(0,x));
	for(int i=1; i<int(nm+10*nm); i++)
		cumulative_tab.push_back(cumulative_tab[i-1]+P(i,x));
		
	return cumulative_tab;
}
	
int electron_multiplication(double const& x){
	vector<double> tab = make_cumulative_tabulation(x);
	double s = r.Rndm();
	
	int ind = 0;
	for(uint i=0; i<tab.size(); i++)
	{
		if (s <= tab[i])
		{
			ind = i;
			break;
		}
	}
		
	return ind;
}
